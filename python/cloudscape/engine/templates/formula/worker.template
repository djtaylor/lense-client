import os
import re
import sys
import time
import json
import errno
import shutil
import requests
import datetime
import platform
import traceback
import tempfile
from threading import Thread
from subprocess import Popen, PIPE, STDOUT
#
# Formula UUID
FORMULA_UUID = '{{ pkg.formula }}'
#
# Agent Formula UUIDs
A_LINUX      = '{{ pkg.a_linux }}'
A_WINDOWS    = '{{ pkg.a_windows }}'
#
# System Attributes
SYS_OS       = '{{ sys.os }}'
SYS_UUID     = '{{ sys.uuid }}'
SYS_DISTRO   = '{{ sys.distroLower }}'
SYS_VERSION  = '{{ sys.version }}'
SYS_ARCH     = '{{ sys.arch }}'
SYS_TMP      = tempfile.gettempdir()
#
# Package Attributes
PKG_UUID     = '{{ pkg.uuid }}'
PKG_SCRIPT   = '{{ pkg.script }}'
PKG_WSPACE   = '{{ pkg.workspace }}'
PKG_EXTIME   = {{ pkg.extime }}
PKG_MODE     = '{{ pkg.mode }}'
#
# Base/Home Directories
CS_BASE      = '{{ cs.base }}'
CS_HOME      = '{{ cs.home }}'
#
# API Attributes
API_TOKEN    = False
API_URL      = False
#
# Events Attributes
E_ENABLED    = {{ param.events }}
E_ID         = '{{ param.events_id }}'
#
# Formula States
F_ERROR      = 'ERROR'
F_SUCCESS    = 'SUCCESS'
F_EXCEPTION  = 'EXCEPTION'
#
# Formula Modes
F_MANAGED    = 'managed'
F_UNMANAGED  = 'unmanaged'
#
# Win32 Imports
if SYS_OS == 'windows':
	import winsrvc
#
# Timestamp
def _ts():
    return datetime.datetime.fromtimestamp(time.time()).strftime('%Y-%m-%d %H:%M:%S')
#
# Formula Events
class Events:

	# Initializer
	def __init__(self):
		
		# API error message container
		self.api_error = None
		
		# API request headers
		self.headers = { 'Content-type': 'application/json', 'Accept': 'text/plain' }
		
	# Construct events handler
	def construct(self, api_url=False, api_token=False):
		global API_URL, API_TOKEN
		API_URL   = False if (api_url == 'False') else api_url
		API_TOKEN = False if (api_token == 'False') else api_token
		
		# Set the API error if no token provided
		self.api_error = None if (API_TOKEN) else 'Cannot use formula events, no API token set'
		
	# Parse API response
	def _parse_response(self, obj):
        ro = {}
        
        # Look for the status code
        if hasattr(obj, 'status_code'):
            ro['code'] = obj.status_code
        if hasattr(obj, 'code'):
            ro['code'] = obj.code
        
        # Look for the return body
        if hasattr(obj, 'content'):
            ro['body'] = obj.content
        if hasattr(obj, 'text'):
            ro['body'] = obj.text
        if callable(getattr(obj, 'text')):
            ro['body'] = obj.text()
        
        # Return the formatted response
        return ro
		
	# Submit request
	def _request(self, action, method, data):
		
		# API request parameters
        event_url = '%s/formula/event' % API_URL
        r_data    = { 'api_user': SYS_UUID, 'api_token': API_TOKEN, 'action': action, '_data': data }
        r_handler = getattr(requests, method)
        r_rsp     = self._parse_response(r_handler(event_url, data=json.dumps(r_data), headers=self.headers))
		
		# Return the response
		return int(r_rsp['code']), r_rsp['body']
		
	# Set event
	def set(self, id, meta=None):
		if not API_TOKEN:
			return False, self.api_error
		if not E_ENABLED:
			return True
	
		# Set the event ID
		event_id = '%s-%s' % (E_ID, id)
	
		# Set the request data
		rdata = {'event_id': event_id}
		if meta:
			rdata['event_meta'] = meta
	
		# Submit the API request
		code, msg = self._request(action='set', method='post', data=rdata)
    
       	# Return the response
       	if code != 200:
       		return False, msg
       	return True, msg
	
	# Wait for event
	def wait(self, id, timeout):
		if not API_TOKEN:
			return False, self.api_error
		if not E_ENABLED:
			return True
			
		# Set the event ID
		event_id = '%s-%s' % (E_ID, id)
			
		# Submit the API request
		code, msg = self._request(action='wait', method='get', data={'event_id': event_id, 'event_timeout': timeout})
    
       	# Return the response
       	if code != 200:
       		return False, msg
       	return True, json.loads(msg)['event_meta']
#
# Formula Logger
class JSONLogger:
    
    # Initializer
    def __init__(self, file):
        
        # Open the log file handle
        self._logf = open(file, 'w')
        
        # Log object and counter
        self._log  = {}
        self._logc = 0
        
    # Success message
    def success(self, msg):
        self._log[self._logc] = { 'time': _ts(), 'type': F_SUCCESS, 'msg': msg }
        self._logc += 1
        
    # Exception
    def exception(self, tb):
    	self._log[self._logc] = { 'time': _ts(), 'type': F_EXCEPTION, 'traceback': tb }
        self._logc += 1
        
    # Error message
    def error(self, msg, err=None):
        self._log[self._logc] = { 'time': _ts(), 'type': F_ERROR, 'msg': msg, 'error': repr(err) }
        self._logc += 1
        
    # Set results
    def results(self, res):
        _results = {
            'log': self._log,
            'results': res
        }
        self._logf.write(json.dumps(_results))
        self._logf.close()
#
# Formula Worker
class Worker:

	# Initializer
	def __init__(self):
	
		# Formula start time
        self.start_time = _ts()

        # Result properties and log object
        self.results    = self._result_properties()
        self.log        = JSONLogger(self.results['log'])

		# Event hander
		self.event      = Events()

        # Initialize the results log
        self._init_results()

        # SELinux enabled flag
        self.selinux    = self._sestatus()

		# Get a list of installed packages in Linux
		self.packages   = self._get_packages()

		# Load Linux helper classes
		if SYS_OS == 'linux':
			
			# Import helper classes
			try:
			    import cloudscape.common.ifconfig as ifconfig
				from cloudscape.common.sysctl import SysCtl
				from cloudscape.common.cparse import CParse
		
			    # Helper class instances
			    self.ifconfig = ifconfig
			    self.sysctl   = SysCtl()
			    self.cparse   = CParse()
			except:
			    self.ifconfig = None
			    self.sysctl   = None
			    self.cparse   = None

    # Initialize Results
    def _init_results(self):
    	self.mkdir(self.results['dir'])

    # SELinux Status
    def _sestatus(self):
        if SYS_OS == 'linux':
            
            # Check if 'sestatus' even exists
            sestatus = Popen(['which', 'sestatus'], stdout=PIPE)
            sestatus.communicate()
            if not sestatus.returncode == 0: return False
            
            # Check if SELinux is enabled
            secheck  = Popen(['sestatus'], stdout=PIPE)
            out, err = secheck.communicate()
            for line in out.split('\n'):
                if re.match(r'^.*status.*enabled.*$', line):
                    return True
            return False
                
        # Non-Linux server
        return False

	# Set event
	def event_set(self, id, meta=None):
		if not API_TOKEN:
			self.log.error('Failed to set event \'%s\': %s' % (id, self.event.api_error))
    		self.set_results(1, F_ERROR, 'Could not set formula event')

		# Set the event
		ok, msg = self.event.set(id, meta)
		if not ok:
			self.log.error('Failed to set event \'%s\': %s' % (id, str(msg)))
    		self.set_results(1, F_ERROR, 'Could not set formula event')
    	else:
    		self.log.success('Successfully set event \'%s\'' % id)

	# Wait for event
	def event_wait(self, id, timeout=600):
		if not API_TOKEN:
			self.log.error('Failed to wait for event \'%s\': %s' % (id, self.event.api_error))
    		self.set_results(1, F_ERROR, 'Could not wait for formula event')

		# Wait for the event
		ok, msg = self.event.wait(id, timeout)
		if not ok:
			self.log.error('Failed to wait for event \'%s\': %s' % (id, str(msg)))
    		self.set_results(1, F_ERROR, 'Could not set formula event')
    	else:
    		self.log.success('Successfully waited for event \'%s\'' % id)

		# Return any event metadata
		return msg

    # Set Path DS
    def _set_path(self, path):
        ds = r'/' if SYS_OS == 'linux' else r'\\'
        return re.sub(r'[\/|\\]', ds, path)

    # User Check
    def _user_exists(self, name):
        usrcheck = Popen(['cat', '/etc/passwd'], stdout=PIPE)
        out, err = usrcheck.communicate()
        for line in out.split('\n'):
            if re.match(r'^%s:.*$' % name, line):
                return True
        return False

    # Group Check
    def _group_exists(self, name):
        grpcheck = Popen(['cat', '/etc/group'], stdout=PIPE)
        out, err = grpcheck.communicate()
        for line in out.split('\n'):
            if re.match(r'^%s:.*$' % name, line):
                return True
        return False

    # Result Properties
    def _result_properties(self):
    	dir = {}
    	log = {}
    
    	# Base directory
    	dir[F_MANAGED]   = '%s/formula/%s' % (CS_HOME, PKG_UUID)
    	dir[F_UNMANAGED] = '%s/%s' % (SYS_TMP, PKG_UUID)
    	
    	# Log file
    	log[F_UNMANAGED] = '%s/%s.log' % (SYS_TMP, PKG_UUID)
    	log[F_MANAGED]   = '%s/log/formula/%s.log' % (CS_HOME, PKG_UUID)
    
    	# Return the constructed results properties
        return {
        	'dir':   self._set_path(dir[PKG_MODE]),
        	'owner': 'cloudscape',
        	'log':   self._set_path(log[PKG_MODE])
        }
            
    # Append to File
    def _append(self, str, file):
        if not os.path.isfile(file):
            return False
        _fh = open(file, 'a')
        _fh.write('%s\n' % str)
        _fh.close()
        return True
    
    # Check if package installed
    def _package_installed(self, pkg):
        mb = 'Queried package [%s]' % pkg
    	for line in self.packages:
    		if pkg in line:
    			self.log.success('%s:INSTALLED' % mb)
    			return True
    	self.log.success('%s:NOT_INSTALLED' % mb)
    	return False
    
    # Get packages list
    def _get_packages(self):
    	if SYS_OS == 'linux':
	    	pkg_cmd  = ['rpm', '-qa'] if (SYS_DISTRO == 'centos') else ['dpkg', '-l']
	    	pkg_proc = Popen(pkg_cmd, stdout=PIPE)
	    	pkg_out  = pkg_proc.communicate()
	    	pkg_list = pkg_out[0].split('\n')
	    	self.log.success('Constructed installed packages list: "%s"' % ' '.join(pkg_cmd))
	    	return pkg_list
	    else:
	    	return []
    
    # Set IPTables
    def set_iptables(self, name, action, chains, save, rules):
    
    	# Try to import 'python-iptables'
    	try:
    		import cloudscape.common.iptc as iptc
    	except Exception as e:
    		self.log.error(mb, str(e))
    		self.set_results(1, F_ERROR, 'Could not import IPTables module, please check your installation')
    
    	# Set the base attributes
    	mb      = 'set_iptables(name="%s", action="%s", chains="%s", save="%s", rules={...})' % (name, action, chains, save)
    	_table  = iptc.Table(iptc.Table.FILTER)
    	_chains = [c.name for c in _table.chains]
    
    	# Create/Replace Ruleset
    	if (action == 'create') or (action == 'create_or_replace') or (action == 'replace'):
    		
    		# If the chain already exists
    		if name in _chains:
    			if not (action == 'create_or_replace') and not (action == 'replace'):
    				self.log.error(mb)
					self.set_results(1, F_ERROR, 'The chain already exists in the filter table, must use action "create_or_replace" or "replace" instead')
    		
    			# Flush and update the existing chain
    			chain = iptc.Chain(_table, name)
    			chain.flush()
    		
    		# Create a new chain
    		else:
    		
    			# If trying to replace a non-existent chain
    			if action == 'replace':
    				self.log.error(mb)
					self.set_results(1, F_ERROR, 'The chain already does not yet exist, must use action "create" or "create_or_replace" instead')
    		
    			# Create a new chain
	    		chain = _table.create_chain(name)
	    		for _tc in chains:
	    			rule = iptc.Rule()
	            	rule.target = iptc.Target(rule, name)
	            	tc   = iptc.Chain(iptc.Table(iptc.Table.FILTER), _tc)
	            	tc.append_rule(rule)
    			
    		# Process the rules
    		for rn,rv in sorted(rules.iteritems(), key=lambda (k,v): (k,v)):
    			rule          = iptc.Rule()
    			
    			# Protocol
	            if 'proto' in rv:
	                rule.protocol = rv['proto']
	
	            # Action
	            if 'action' in rv:
	                rule.target   = iptc.Target(rule, rv['action'])
	
	            # State
	            if 'state' in rv:
	                match         = iptc.Match(rule, 'state')
	                match.state   = rv['state']
	                rule.add_match(match)
	
	            # Destination Port
	            if ('dport' in rv) and ('proto' in rv):
	                match         = iptc.Match(rule, rv['proto'])
	                match.dport   = str(rv['dport'])
	                rule.add_match(match)
	
	            # Source Port
	            if ('sport' in rv) and ('proto' in rv):
	                match         = iptc.Match(rule, rv['proto'])
	                match.sport   = str(rv['sport'])
	                rule.add_match(match)
	
	            # Inbound Interface
	            if 'nic' in rv:
	                rule.set_in_interface(rv['nic'])
	
	            # Source Address
	            if 'source' in rv:
	                rule.set_src(rv['source'])
	
	            # Destination Address
	            if 'dest' in rv:
	                rule.set_dst(rv['dest'])
	
	            # Add Rule
	            chain.append_rule(rule)
    
    # Set packages
    def set_packages(self, pkgs, action):
    	mb = 'set_packages([%s], "%s")' % (','.join(pkgs), action)
    
    	# Package manager
    	pkgman  = {
    		'centos': 'yum',
    		'ubuntu': 'apt-get'
    	}
    
    	# Base command
    	basecmd = '%s %s -y' % (pkgman[SYS_DISTRO], action)
    	
    	# Unattended installation on Ubuntu
    	if SYS_DISTRO == 'ubuntu':
    		os.environ['DEBIAN_FRONTEND'] = 'noninteractive'
    	
    	# Build the package command string
    	pkgcmd  = '%s %s' % (basecmd, ' '.join(pkgs))
    
    	# Run the package manager
    	self.run_command(pkgcmd, 0)
    	self.log.success(mb)
    
    # Set debconf value
    def debconf_set(self, params):
    	if SYS_DISTRO != 'ubuntu':
    		return False
    
    	# Make sure debconf-utils are available
    	self.set_packages(['debconf-utils'], 'install')
    
    	# Process each debconf entry
    	for l in params:
    		os.system('echo "%s %s %s %s" | debconf-set-selections' % (l[0], l[1], l[2], l[3]))
    
    # Add repository key
    def _add_repo_key(self, keys):
    	mb = 'add_repo_key([%s])' % ','.join(keys)
    
    	# Ubuntu Repo Keys
    	if SYS_DISTRO == 'ubuntu':
    		for k in keys:
	    		key_params = k.split('@')
	    		self.run_command('apt-key adv --keyserver %s --recv-keys %s' % (key_params[1], key_params[0]))
    		
    	# CentOS Repo Keys
    	if SYS_DISTRO == 'centos':
    		for k in keys:
    			self.run_command('rpm --import %s' % (k))
    	
    	# Key imported
    	self.log.success(mb)
    
    # Add repository
    def add_repo(self, paths, keys=None):
    	mb = 'add_repo([%s])' % ','.join(paths)
    	
    	# If setting up any repository keys
    	if keys:
    	    self._add_repo_key(keys)
    	
    	# Ubuntu Apt Repositories
    	if SYS_DISTRO == 'ubuntu':
    	
    		# Make sure 'python-software-properties' is available
    		if not self._package_installed('python-software-properties'):
    			self.set_packages(['python-software-properties'], 'install')
    	
    		# Install each repo
    		for path in paths:
    			self.run_command(['apt-add-repository', '-y', path])
    			self.log.success(mb)
    		
    	# CentOS YUM Repositories
    	if SYS_DISTRO == 'centos':
    		for path in paths:
    			rpm_query = re.compile(r'^.*\/([^\/]*)\.rpm$').sub(r'\g<1>', path)
    			
    			# Check if the repo RPM is already installed
    			if self._package_installed(rpm_query):
    				continue
    					
    			# Install the repository
    			self.run_command('rpm -Uvh %s' % path, 0)
    	
    	# Rebuild repo sources
    	rebuild = 'yum clean all' if (SYS_DISTRO == 'centos') else 'apt-get update' 
    	self.run_command(rebuild)
    	
    	# Repository created
    	self.log.success(mb)
    				
    # Set Service
    def set_service(self, name, state, auto=None):
    	mb = 'set_service("%s", "%s", auto=%s)' % (name, state, repr(auto))
    	
    	# Windows Services
    	if SYS_OS == 'windows':
    		try:
    		
    			# Create the service handle
    			svc = winsrvc.WService(name)
    			
    			# Set the service to the target state
    			if state == 'start':
	    			svc.start()
	    		if state == 'stop':
	    			svc.stop()
	    		if state == 'restart':
	    			svc.restart()
	    			
	    		# Set the service runlevel
	    		if not auto == None:
		    		boot_state = 'automatic' if (auto == True) else 'manual'
		    		svc.setstartup(boot_state)
	    		
	    		# Delete the service handle
	    		del svc
	    		self.log.success(mb)
	    		
    		# Something failed
    		except Exception as e:
    			self.log.error(mb, str(e))
				self.set_results(1, F_ERROR, 'Failed to set service <%s> to state <%s>' % (name, state))
    	
    	# Linux Services
    	if SYS_OS == 'linux':
    	
    		# CentOS
    		if SYS_DISTRO == 'centos':
    			self.run_command(['chkconfig', name, '--add'], 0)
    			if not auto == None:
	    			cc_state = 'on' if (auto == True) else 'off'
	                self.run_command(['chkconfig', name, cc_state], 0)
    		
    		# Ubuntu
    		if SYS_DISTRO == 'ubuntu':
    			self.run_command(['update-rc.d', name, 'defaults'], 0)
    			if not auto == None:
    				ur_state = 'enable' if (auto == True) else 'remove'
                	self.run_command(['update-rc.d', name, ur_state], 0)
            
            # Set the service state
            srv_proc  = Popen(['service', name, state], stdout=PIPE, stderr=PIPE)
            exit_code = srv_proc.wait()
            if exit_code != 0:
                self.log.error(mb)
                self.set_results(1, F_ERROR, 'Failed to set service <%s> to state <%s>' % (name, state))
            self.log.success(mb)
            
    # Make Directory 
    def mkdir(self, dir, mode=None, user=None, group=None, context=None):
        mb = 'mkdir("%s")' % dir
        try:
            os.makedirs(dir)
           
            # Linux Permissions
            if SYS_OS == 'linux':
                
                # Set file mode
                if mode:
                    self.run_command(['chmod', str(mode), dir], 0)
                
                # Set file owner
                if user or group:
                    if user and not group:
                        self.run_command(['chown', user, dir], 0)
                    if group and not user:
                        self.run_command(['chgrp', group, dir], 0)
                    if user and group:
                        self.run_command(['chown', '%s:%s' % (user,group), dir], 0)
                
                # Set file context
                if context:
                    if self.selinux:
                        self.run_command(['chcon', context, dir], 0)
            self.log.success(mb)
        except Exception as e:
        	if e.errno == errno.EEXIST:
        		self.log.success(mb)
        	else:
            	self.log.error(mb, str(e))
            	self.set_results(1, 'ERROR', 'Failed to create directory tree \'%s\'' % dir)
            
    # Make File
    def mkfile(self, file, mode=None, user=None, group=None, context=None, content=None):
        _fh = open(file, 'a')
        
        # File contents
        if content:
            _fh.write('%s\n' % content)
        _fh.close()
        
        # Linux Permissions
        if SYS_OS == 'linux':
            
            # Set file mode
            if mode:
                self.run_command(['chmod', str(mode), file], 0)
            
            # Set file owner
            if user or group:
                if user and not group:
                    self.run_command(['chown', user, file], 0)
                if group and not user:
                    self.run_command(['chgrp', group, file], 0)
                if user and group:
                    self.run_command(['chown', '%s:%s' % (user,group), file], 0)
            
            # Set file context
            if context:
                if self.selinux:
                    self.run_command(['chcon', context, file], 0)
                    
    # Remove Contents 
    def rm(self, path):
        mb = 'rm("%s")' % path
        try:
            os.remove(path)
            self.log.success(mb)
        except:
            try:
                shutil.rmtree(path)
                self.log.success(mb)
            except Exception as e:
                self.log.error(mb, str(e))
                self.set_results(1, 'ERROR', 'Failed to remove contents \'%s\'' % path)
            
    # Copy Contents 
    def cp(self, src, dest):
        mb = 'cp("%s", "%s")' % (src, dest)
        try:
            shutil.copytree(src, dest)
            self.log.success(mb)
        except OSError as e:
            if (e.errno == errno.ENOTDIR) or (e.errno == errno.EINVAL):
                shutil.copy(src, dest)
                self.log.success(mb)
            else: 
            	self.log.success(mb, str(e))
                self.set_results(1, 'ERROR', 'Failed to copy contents \'%s\' to \'%s\'' % (src, dest))
            
    # System Attribute Check
    def system_is(self, os=None, distro=None, version=None, bit=None):
        arch_32 = ['i686', 'i386', '32bit']
        arch_64 = ['x86_64', '64bit', 'AMD64']
        
        # OS Type
        if (os) and not (os.lower() == SYS_OS.lower()):
            return False
        
        # OS Distribution
        if (distro) and not (distro.lower() == SYS_DISTRO.lower()):
            return False
        
        # OS Version
        if (version) and not (version in SYS_VERSION):
            return False
        
        # OS Bit (32 or 64
        if arch == 32:
            if not SYS_ARCH in arch_32:
                return False
        if arch == 64:
            if not SYS_ARCH in arch_64:
                return False
        return True
            
    # Construct Path 
    def construct_path(self, path):
        parent = re.compile(r'(^.*)[\/|\\][^\/|\\]*$').sub(r'\g<1>', path)
        self.mkdir(parent)
            
    # Run Command 
    def run_command(self, cmd, expects=0):
        cmds = cmd if isinstance(cmd, list) else cmd.split()
        
        # Run the command and check the exit code
        try:
	        proc      = Popen(cmds, stdout=PIPE, stderr=PIPE, env=os.environ, shell=True if (SYS_OS == 'windows') else False)
	        out, err  = proc.communicate()
	        exit_code = proc.returncode
	        if int(exit_code) != int(expects):
	            self.log.error(cmd, str(err))
	            self.set_results(exit_code, F_ERROR, 'Command did not return expected exit code')
	        
	        # Received expected exit code, return and continue
	        self.log.success(cmd)
	        return exit_code, out, err
        except Exception as e:
            self.log.error(cmd, str(e))
	    	self.set_results(1, F_ERROR, 'Encountered exception when running command')
       
    # Deploy File   
    def deploy_file(self, src, dest, link=None, user=None, group=None, mode=None, context=None, force=False):
        
        # Make sure the source file exists
        if not os.path.isfile(src):
            self.set_results(1, F_ERROR, 'Source file "%s" not found on the system' % src)
    
        # If overwriting a file, make sure that force is set to true
        if os.path.isfile(dest) or os.path.isdir(dest):
            if not force:
                self.set_results(1, F_ERROR, 'Destination path "%s" already exists, force must be set to true to overwrite' % dest)
    
        # Construct the parent path
        self.construct_path(dest)
    
        # Deploy the file
        self.cp(src, dest)
    
        # Linux Permissions
        if SYS_OS == 'linux':
            
            # If changing ownership
            if user or group:
                if user and not group:
                    self.run_command(['chown', user, dest], 0)
                if group and not user:
                    self.run_command(['chgrp', group, dest], 0)
                if user and group:
                    self.run_command(['chown', '%s:%s' % (user,group), dest], 0)

            # If setting the context and SELinux is enabled
            if context:
                if self.selinux:
                    self.run_command(['chcon', context, dest], 0)
                    
            # If setting the mode
            if mode:
                self.run_command(['chmod', mode, dest], 0)

            # If setting a file link
            if link:
                if os.path.islink(link):
                    if not force:
                        self.set_results(1, F_ERROR, 'Target link "%s" for "%s" already exists, force must be set to true to relink' % (link, dest))
                    self.run_command(['ln', '-fs', dest, link], 0)
                else:
                    self.run_command(['ln', '-s', dest, link], 0)
        
    # Deploy Folder
    def deploy_folder(self, src, dest, link=None, user=None, group=None, mode=None, context=None, force=False):
        replace = False
            
        # Make sure the source file exists
        if not os.path.isdir(src):
            self.set_results(1, F_ERROR, 'Source directory "%s" not found on the system' % src)
    
        # If overwriting a file, make sure that force is set to true
        if os.path.isdir(dest):
            if not force:
                self.set_results(1, F_ERROR, 'Destination directory "%s" already exists, force must be set to true to overwrite' % dest)
            replace = True

        # Construct the parent path
        self.construct_path(dest)
    
        # If replacing the directory
        if replace:
            self.rm(dest)
            self.cp(src, dest)
        else:
            self.cp(src, dest)
    
        # Linux Permissions
        if SYS_OS == 'linux':
            
            # If changing ownership
            if user or group:
                if user and not group:
                    self.run_command(['chown', user, dest], 0)
                if group and not user:
                    self.run_command(['chgrp', group, dest], 0)
                if user and group:
                    self.run_command(['chown', '%s:%s' % (user,group), dest], 0)

            # If setting the context and SELinux is enabled
            if context:
                if self.selinux:
                    self.run_command(['chcon', context, dest], 0)
                    
            # If setting the mode
            if mode:
            	modes = {}
            	for cmode in mode.split('/'):
            		cmode_array = cmode.split(':')
            		modes[cmode_array[0]] = cmode_array[1]
            	for flag, val in modes.iteritems():
            		if (flag == 'F') and (val):
            			self.run_command(['find', dest, '-type', 'f', '-exec', 'chmod', val, '{}\;'], 0)
            		if (flag == 'D') and (val):
            			self.run_command(['find', dest, '-type', 'd', '-exec', 'chmod', val, '{}\;'], 0)

            # If setting a file link
            if link:
                if os.path.islink(link):
                    if not force:
                        self.set_results(1, F_ERROR, 'Target link "%s" for "%s" already exists, force must be set to true to relink' % (link, dest))
                    self.run_command(['ln', '-fs', dest, link], 0)
                else:
                    self.run_command(['ln', '-s', dest, link], 0)
    
    # Deploy User 
    def deploy_user(self, name, group=None, home=None, pubkey=None, umask='022'):
        if SYS_OS == 'linux':
            
            # Check if the user exists
            if self._user_exists(name):
                self.set_results(1, F_ERROR, 'The user account and/or home directory already exist')
            
            # Set the default home
            home  = ('/home/%s' % name) if not home else home
            
            # Set the group string
            if group:
                if not self._group_exists(group):
                    self.run_command(['groupadd', group], 0)
                group_str = '-g %s' % group
            else:
                group = name
                group_str = ''
            
            # Create the user account
            self.run_command('useradd -d %s -m -s /bin/bash %s %s' % (home, group_str, name), 0)
            
            # Set the umask
            self._append('umask %s' % umask, '%s/.bashrc' % home)
       
            # Add a public key
            if pubkey:
                
                # SSH directory
                self.mkdir('%s/.ssh' % home, 
                    mode    = 700, 
                    user    = name, 
                    group   = group, 
                    context = 'unconfined_u:object_r:ssh_home_t:s0'
                )
                
                # Authorized keys
                self.mkfile('%s/.ssh/authorized_keys' % home, 
                    mode    = 640, 
                    user    = name, 
                    group   = group, 
                    context = 'unconfined_u:object_r:ssh_home_t:s0',
                    content = pubkey
                )
            
    # Set Results
    def set_results(self, exit_code=1, exit_status='UNKNOWN', exit_msg='No exit message provided'):
        
        # Create the formula log
        self.log.results({
    		'formula':     FORMULA_UUID,
			'sys_uuid':    SYS_UUID,
			'sys_version': SYS_VERSION,
			'sys_arch':    SYS_ARCH,
			'start_time':  self.start_time,
			'end_time':    _ts(),
			'exit_code':   exit_code,
			'exit_status': exit_status,
			'exit_msg':    exit_msg
        })
    
    	# Linux agent deployment
    	if (FORMULA_UUID == A_LINUX) and (PKG_MODE == F_UNMANAGED):
        	f_log = '%s/log/formula' % CS_HOME
        	
        	# Deployment success
            if exit_code == 0:
            	self.mkdir(f_log)
            	self.cp(self.results['log'], f_log)
            	self.rm(self.results['log'])
            	self.rm('/tmp/%s.tar.gz' % PKG_UUID)
            
    	# Set ownership of the log files and remove the initial package
    	if SYS_OS == 'linux':
            os.system('chown -R cloudscape:cloudscape %s/log/formula' % CS_HOME)
    		
        # Remove the package workspace and archive
        self.rm(PKG_WSPACE)
        self.rm('%s.tar.gz' % PKG_WSPACE)
        self.rm('%s.tar.gz.enc' % PKG_WSPACE)
        
        # Exit the script
        sys.exit(exit_code)